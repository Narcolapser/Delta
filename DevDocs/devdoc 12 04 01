I've made a new class, Buffer, that will wrap all the functions concerning reading, writing, and binding buffers. One more thing pulled away from the library interface. particularly I've seperated the constructs of Buffer and Attribute. Which needed to happen because not all buffers were attributes. 

I've given up on buffer objects for the time being. The reason for this unfortunate decission is they are just recently being supported by OpenGl 4.2, my desktop has OpenGL 4.1. so there is no way I'm getting UBOs working on my netbook, and until after easter I need the ability to develop on my netbook. 

I've also fixed mesh's loading code so that it can tollerate quads. now it simply translates them into two triangles. The exact result may not be deterministic depending on the way the exporter for your program works.

The last thing to do before I finish Alpha 6 (aside from getting the new buffer class fully functional, I lost drawing when it was brought online) I need to create the resource manager. This presents some interesting questions, what exactly is the resource manager's job here? To keep it nice and small to begin with, I'm going to have it so that I can just call the appropriate method with a file and it loads it. While currently that seems rather silly and redundant, in the future I might get some extra trickery and magic out of it. For example, UUIDs, shared memory objects, and redundancy prevention. But lets start things simple. You call it, it returns a reference to the new object. 

After staring at the resource manager's empty class definition, I realized that I've got a lot more that really needs to happen before the resource manager has a purpose. My rabit trail started with the thought "Well, I could give this a purpose by having it load a config file." But I still would have to have it return something for that to make any sense. So I though for a little how the actual engine will work. and this is the system I've concluded on:

The engine is to be completely data driven. a single executable represents the engine, it will load a master config file that will inform it from there, kinda like index.html. A game will consist of a set of scenes and navigation between them. for example, the main menu is a scene, and each level is its own scene. There will be functions to change which scene is the active scene. I hope, also, in doing things in this manner I can avoid the painful "game-feels-like-it-has-locked-up" loading screnes. not that I think there won't be any more loading screens, but I'd hope that loading scenes will still call "drawscene();swapbuffers();" on a regular basis enabling it to feel like it is still responsive. if it were a multi-player game, perhaps include a chat window for example.

So, I hope that this would help eliminate the remaining includes from Delta to OpenGL. Progress! Intoduced in the process is the "scene" class. 

Scenes. A scene will contain all the resources that are needed for a scene: Meshes, textures, sound bytes, triggers, etc. if it is needed to make a scene happen, it will be in this class. As well as contain the master render call. scenes themselves don't know if they are active or not. the Delta main class will interface to it's scene. It simply has a pointer that it sends information to when ever it gets something, when a scene sends a call to navigate to the next scene, this pointer is changed and thus changing from menu to the level for example. 

The other class that I'm going to also have to introduce is that of the master ancestor. well gosh. This has grown far to big for this Alpha. I'm need to reconsider what goes into this alpha. Obviously scenes and the resource manager our out of my scope for this alpha. What I'm thinking I'll do is create master ancestor object class and fix what ever broke the rendering.
